#!/usr/bin/env python3
"""
cartographer.py - Codebase Architectural Mapping

WHY THIS SCRIPT EXISTS:
- Generates high-level summary of codebase structure before planning
- Reduces token usage from 150k to <2k for initial planning phase
- Creates "map of the haystack" so agent knows where to look
- Enables SASE "Persistent Memory" pattern for long-term context

KEY ARCHITECTURAL DECISIONS:
- PRE-FLIGHT HOOK: Runs before orchestrator starts main loop
- CODESUM PRIMARY: Uses codesum for semantic summarization
- CUSTOM WALKER FALLBACK: Generates basic map if codesum unavailable
- MARKDOWN OUTPUT: Compatible with plan.md and spec.md format

WINDOWS-SPECIFIC CONSIDERATIONS:
- subprocess.run with shell=False for security
- Windows path handling with pathlib
- UTF-8 encoding for all file operations
"""

import subprocess
import sys
from pathlib import Path
from typing import Optional
import os


def _generate_basic_map(target_dir: Path, output_path: Path) -> None:
    """
    Generate basic file structure map using custom walker.
    
    Fallback when codesum is unavailable.
    
    Args:
        target_dir: Root directory to map
        output_path: Output file path for map
    """
    map_lines = [
        "# Codebase Architectural Map",
        "",
        "## Auto-Generated Structure",
        "",
        "```\n"
    ]
    
    try:
        for root, dirs, files in os.walk(target_dir):
            # Skip common directories
            dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', 'node_modules', 'venv', 'env']]
            
            level = len(Path(root).relative_to(target_dir).parts) if root != str(target_dir) else 0
            indent = "  " * level
            
            # Add directory
            dir_name = Path(root).name if root != str(target_dir) else target_dir.name
            map_lines.append(f"{indent}{dir_name}/")
            
            # Add files
            for file in sorted(files):
                if file.endswith(('.py', '.js', '.ts', '.md', '.json', '.yml', '.yaml')):
                    map_lines.append(f"{indent}  {file}")
    
    except Exception as e:
        map_lines.append(f"Error generating map: {e}")
    
    map_lines.append("```\n")
    map_lines.append("\n## Notes")
    map_lines.append("- Generated by custom walker (codesum unavailable)")
    map_lines.append("- Focuses on source files (.py, .js, .ts, .md)")
    map_lines.append("- Excludes: .git, __pycache__, node_modules, venv")
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(map_lines))


def generate_map(target_dir: Path, output_path: Optional[Path] = None) -> bool:
    """
    Generate codebase architectural map using codesum or fallback.
    
    Primary: codesum (semantic summarization)
    Fallback: Custom walker (basic structure)
    
    Args:
        target_dir: Root directory to analyze
        output_path: Output file path (default: state/codebase_map.md)
        
    Returns:
        True if map generated successfully, False otherwise
    """
    if output_path is None:
        output_path = Path("state") / "codebase_map.md"
    
    print(f" Generating codebase map for: {target_dir}")
    print(f" Output: {output_path}")
    
    # Try codesum first
    try:
        result = subprocess.run(
            ["codesum", str(target_dir)],
            capture_output=True,
            text=True,
            shell=False,
            timeout=30,
            check=True,
            encoding="utf-8"
        )
        
        # Save codesum output
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("# Codebase Architectural Map\n\n")
            f.write("## Generated by codesum\n\n")
            f.write(result.stdout)
            f.write("\n## Metadata\n")
            f.write(f"- Tool: codesum\n")
            f.write(f"- Generated: {Path(target_dir).name}\n")
        
        print(f" Map generated successfully using codesum")
        return True
        
    except FileNotFoundError:
        print(" codesum not found. Using custom walker fallback...")
        _generate_basic_map(target_dir, output_path)
        print(f" Basic map generated using custom walker")
        return True
        
    except subprocess.CalledProcessError as e:
        print(f" codesum failed (exit {e.returncode}). Using custom walker fallback...")
        print(f"   Error: {e.stderr[:200]}")
        _generate_basic_map(target_dir, output_path)
        return True
        
    except subprocess.TimeoutExpired:
        print(" codesum timeout (30s). Using custom walker fallback...")
        _generate_basic_map(target_dir, output_path)
        return True
        
    except Exception as e:
        print(f" Unexpected error: {e}. Using custom walker fallback...")
        _generate_basic_map(target_dir, output_path)
        return True


# TEST SUITE - MUST PASS BEFORE PROCEEDING
if __name__ == "__main__":
    print(" Running cartographer.py comprehensive tests...\n")
    
    import tempfile
    import shutil
    
    # Test 1: Basic map generation with custom walker
    print("Test 1: Custom walker map generation")
    with tempfile.TemporaryDirectory() as tmpdir:
        test_dir = Path(tmpdir) / "test_project"
        test_dir.mkdir()
        
        # Create test files
        (test_dir / "main.py").write_text("# Main file")
        (test_dir / "utils.py").write_text("# Utils")
        subdir = test_dir / "subdir"
        subdir.mkdir()
        (subdir / "helper.py").write_text("# Helper")
        
        output = Path(tmpdir) / "output.md"
        success = generate_map(test_dir, output)
        
        assert success == True, "Should generate map successfully"
        assert output.exists(), "Output file should exist"
        
        content = output.read_text()
        assert "test_project/" in content, "Should include root directory"
        assert "main.py" in content, "Should include Python files"
        assert "subdir/" in content, "Should include subdirectories"
        
    print(" PASS: Custom walker works\n")
    
    # Test 2: Output path handling
    print("Test 2: Output path handling")
    with tempfile.TemporaryDirectory() as tmpdir:
        test_dir = Path(tmpdir) / "project"
        test_dir.mkdir()
        (test_dir / "test.py").write_text("# Test")
        
        # Test with custom output path
        custom_output = Path(tmpdir) / "custom_map.md"
        success = generate_map(test_dir, custom_output)
        
        assert success == True, "Should generate map"
        assert custom_output.exists(), "Should use custom output path"
        
        # Test default output path
        success2 = generate_map(test_dir)
        default_output = Path("state") / "codebase_map.md"
        assert default_output.exists(), "Should use default path"
        default_output.unlink()
        default_output.parent.rmdir()
        
    print(" PASS: Output path handling works\n")
    
    # Test 3: Directory exclusion
    print("Test 3: Directory exclusion")
    with tempfile.TemporaryDirectory() as tmpdir:
        test_dir = Path(tmpdir) / "project"
        test_dir.mkdir()
        
        # Create files in excluded directories
        git_dir = test_dir / ".git"
        git_dir.mkdir()
        (git_dir / "config").write_text("git config")
        
        cache_dir = test_dir / "__pycache__"
        cache_dir.mkdir()
        (cache_dir / "test.pyc").write_text("bytecode")
        
        # Create valid source file
        (test_dir / "main.py").write_text("# Main")
        
        output = Path(tmpdir) / "map.md"
        _generate_basic_map(test_dir, output)
        
        content = output.read_text()
        assert "main.py" in content, "Should include source files"
        assert ".git" not in content, "Should exclude .git directory"
        assert "__pycache__" not in content, "Should exclude __pycache__"
        
    print(" PASS: Directory exclusion works\n")
    
    # Test 4: Error handling
    print("Test 4: Error handling")
    with tempfile.TemporaryDirectory() as tmpdir:
        # Non-existent directory
        fake_dir = Path(tmpdir) / "nonexistent"
        output = Path(tmpdir) / "output.md"
        
        success = generate_map(fake_dir, output)
        # Should fallback gracefully, not crash
        assert isinstance(success, bool), "Should return boolean"
        
    print(" PASS: Error handling works\n")
    
    # Test 5: File type filtering
    print("Test 5: File type filtering")
    with tempfile.TemporaryDirectory() as tmpdir:
        test_dir = Path(tmpdir) / "project"
        test_dir.mkdir()
        
        # Create various file types
        (test_dir / "main.py").write_text("# Python")
        (test_dir / "app.js").write_text("// JavaScript")
        (test_dir / "data.json").write_text("{}")
        (test_dir / "README.md").write_text("# Docs")
        (test_dir / "binary.exe").write_bytes(b"\x00\x01\x02")  # Binary file
        
        output = Path(tmpdir) / "map.md"
        _generate_basic_map(test_dir, output)
        
        content = output.read_text()
        assert "main.py" in content, "Should include .py"
        assert "app.js" in content, "Should include .js"
        assert "data.json" in content, "Should include .json"
        assert "README.md" in content, "Should include .md"
        assert "binary.exe" not in content, "Should exclude binary files"
        
    print(" PASS: File type filtering works\n")
    
    print("=" * 60)
    print(" ALL 5 TESTS PASSED - cartographer.py is production-ready")
    print("=" * 60)
    print("\nNext step: Create context_fetcher.py")
    print("Command: @file context_fetcher.py")
